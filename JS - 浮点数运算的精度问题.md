## [浮点](https://links.jianshu.com/go?to=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3D%E6%B5%AE%E7%82%B9%26spm%3D1001.2101.3001.7020)数溢出

平时我们在进行数据运算的时候，会遇到浮点数溢出的情况

```js
// 加法
0.1 + 0.2 = 0.30000000000000004
0.2 + 0.4 = 0.6000000000000001
 
// 减法
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法
19.9 * 100 = 1989.9999999999998
9.7 * 100 = 969.9999999999999
 
// 除法 
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999

 // 比较
 0.1 + 0.2 === 0.3 // false
 (0.3 - 0.2) === (0.2 - 0.1) // false

```

## 导致原因

JavaScript 内部只有一种数字类型Number，也就是说，JavaScript 语言的底层根本没有整数，所有数字都是以IEEE-754标准格式64位浮点数形式储存，1与1.0是相同的。因为有些小数以二进制表示位数是无穷的。JavaScript会把超出53位之后的二进制舍弃，所以涉及小数的比较和运算要特别小心。

##### 浮点数

> JS的浮点数实现遵循IEEE 754标准，采用双`精度`存储（double precision），使用64位固定长度来表示，其中1位用来表示符号位，11位用来表示指数，52位表示尾数。

- 符号位(sign)：第1位是正负数符号位，0代表正数，1代表负数
- 指数位(Exponent)：中间11位存储指数，用来表示次方数
- 尾数位(mantissa)：最后的52位是尾数，超出部分自动进一舍零

##### 计算过程

十进制的0.1和0.2都会被转换成二进制，但由于浮点数用二进制表达时是无穷的

```
0.1*2=0.2--0
0.2*2=0.4--0
0.4*2=0.8--0
0.8*2=1.6--1
0.6*2=1.2--1
……
0.1——>0.0001 1001 1001 1001 ...(1001循环)
0.2——>0.0011 0011 0011 0011 ...(0011循环)
0.0100 1100 1100 1100
```

IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为：

```
0.0100110011001100110011001100110011001100110011001100 
```

因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差。
